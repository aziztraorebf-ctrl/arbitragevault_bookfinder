import pytest\nfrom decimal import Decimal\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.exc import IntegrityError\n\n# Import models and repositories\nfrom backend.app.models.analysis import Analysis, Base\nfrom backend.app.models.batch import Batch\nfrom backend.app.repositories.analysis import AnalysisRepository\nfrom backend.app.repositories.base import (\n    FilterCriteria, FilterCondition, DuplicateIsbnInBatchError, \n    InvalidSortFieldError, InvalidFilterFieldError\n)\n\n@pytest.fixture\ndef db_session():\n    \"\"\"Create in-memory SQLite session for testing\"\"\"\n    engine = create_engine(\"sqlite:///:memory:\", echo=False)\n    Base.metadata.create_all(engine)\n    \n    Session = sessionmaker(bind=engine)\n    session = Session()\n    session.expire_on_commit = False  # Important pour tests\n    \n    yield session\n    session.close()\n\n@pytest.fixture\ndef sample_batch(db_session):\n    \"\"\"Create sample batch for testing\"\"\"\n    batch = Batch(id=1, name=\"Test Batch\")\n    db_session.add(batch)\n    db_session.commit()\n    return batch\n\n@pytest.fixture\ndef analysis_repo(db_session):\n    \"\"\"Create AnalysisRepository instance\"\"\"\n    return AnalysisRepository(db_session)\n\n# ============================================================================\n# PATCH 1 TESTS: isbn_list support in list_filtered\n# ============================================================================\n\n@pytest.mark.asyncio\nasync def test_patch1_isbn_list_filtering(analysis_repo, sample_batch, db_session):\n    \"\"\"Test filtering by ISBN list\"\"\"\n    \n    # Create test data with different ISBNs\n    analyses = [\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN001\", roi_percent=Decimal(\"25.5\")),\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN002\", roi_percent=Decimal(\"35.2\")),\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN003\", roi_percent=Decimal(\"45.8\")),\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN004\", roi_percent=Decimal(\"15.1\"))\n    ]\n    \n    for analysis in analyses:\n        db_session.add(analysis)\n    db_session.commit()\n    \n    # Test filtering by specific ISBN list\n    result = await analysis_repo.list_filtered(\n        batch_id=1,\n        isbn_list=[\"ISBN001\", \"ISBN003\"]\n    )\n    \n    assert result.total == 2\n    returned_isbns = {item.isbn_or_asin for item in result.items}\n    assert returned_isbns == {\"ISBN001\", \"ISBN003\"}\n\n@pytest.mark.asyncio\nasync def test_patch1_isbn_list_normalization(analysis_repo, sample_batch, db_session):\n    \"\"\"Test ISBN normalization in list_filtered\"\"\"\n    \n    # Create analysis with normalized ISBN\n    analysis = Analysis(batch_id=1, isbn_or_asin=\"ISBN001\", roi_percent=Decimal(\"25.5\"))\n    db_session.add(analysis)\n    db_session.commit()\n    \n    # Test search with lowercase/spaces\n    result = await analysis_repo.list_filtered(\n        batch_id=1,\n        isbn_list=[\" isbn001 \", \"ISBN999\"]  # Mixed case/whitespace\n    )\n    \n    assert result.total == 1\n    assert result.items[0].isbn_or_asin == \"ISBN001\"\n\n@pytest.mark.asyncio\nasync def test_patch1_isbn_list_with_other_filters(analysis_repo, sample_batch, db_session):\n    \"\"\"Test isbn_list combined with other filters\"\"\"\n    \n    analyses = [\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN001\", roi_percent=Decimal(\"25.5\")),\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN002\", roi_percent=Decimal(\"35.2\")),\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN003\", roi_percent=Decimal(\"5.8\"))  # Low ROI\n    ]\n    \n    for analysis in analyses:\n        db_session.add(analysis)\n    db_session.commit()\n    \n    # Combine ISBN list + ROI filter\n    filters = [FilterCriteria(field=\"roi_percent\", condition=FilterCondition.GTE, value=Decimal(\"20\"))]\n    \n    result = await analysis_repo.list_filtered(\n        batch_id=1,\n        isbn_list=[\"ISBN001\", \"ISBN002\", \"ISBN003\"],\n        filters=filters\n    )\n    \n    assert result.total == 2  # Only ISBN001 and ISBN002 have ROI >= 20\n    returned_isbns = {item.isbn_or_asin for item in result.items}\n    assert returned_isbns == {\"ISBN001\", \"ISBN002\"}\n\n# ============================================================================\n# PATCH 2 TESTS: Strict sort field validation\n# ============================================================================\n\n@pytest.mark.asyncio\nasync def test_patch2_valid_sort_field(analysis_repo, sample_batch, db_session):\n    \"\"\"Test sorting with valid field\"\"\"\n    \n    analyses = [\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN001\", roi_percent=Decimal(\"15.5\")),\n        Analysis(batch_id=1, isbn_or_asin=\"ISBN002\", roi_percent=Decimal(\"25.2\"))\n    ]\n    \n    for analysis in analyses:\n        db_session.add(analysis)\n    db_session.commit()\n    \n    # Test valid sort field\n    result = await analysis_repo.list_filtered(\n        batch_id=1,\n        sort_by=\"roi_percent\",\n        sort_desc=True\n    )\n    \n    assert result.total == 2\n    assert result.items[0].roi_percent > result.items[1].roi_percent\n\n@pytest.mark.asyncio\nasync def test_patch2_invalid_sort_field_raises_error(analysis_repo, sample_batch, db_session):\n    \"\"\"Test that invalid sort field raises InvalidSortFieldError\"\"\"\n    \n    analysis = Analysis(batch_id=1, isbn_or_asin=\"ISBN001\", roi_percent=Decimal(\"15.5\"))\n    db_session.add(analysis)\n    db_session.commit()\n    \n    # Test invalid sort field\n    with pytest.raises(InvalidSortFieldError) as exc_info:\n        await analysis_repo.list_filtered(\n            batch_id=1,\n            sort_by=\"invalid_field\"  # Not in SORTABLE_FIELDS\n        )\n    \n    assert \"invalid_field is not sortable\" in str(exc_info.value)\n    assert \"roi_percent\" in str(exc_info.value)  # Should show allowed fields\n\n# ============================================================================\n# PATCH 3 TESTS: Balanced strategy with Decimal precision\n# ============================================================================\n\n@pytest.mark.asyncio\nasync def test_patch3_balanced_strategy_decimal_precision(analysis_repo, sample_batch, db_session):\n    \"\"\"Test balanced strategy uses Decimal for precision\"\"\"\n    \n    analyses = [\n        Analysis(\n            batch_id=1, \n            isbn_or_asin=\"ISBN001\", \n            roi_percent=Decimal(\"40.0\"),    # High ROI\n            velocity_score=Decimal(\"20.0\")   # Low velocity\n        ),\n        Analysis(\n            batch_id=1, \n            isbn_or_asin=\"ISBN002\", \n            roi_percent=Decimal(\"20.0\"),    # Low ROI\n            velocity_score=Decimal(\"60.0\")   # High velocity\n        )\n    ]\n    \n    for analysis in analyses:\n        db_session.add(analysis)\n    db_session.commit()\n    \n    # Test balanced strategy\n    result = await analysis_repo.top_n_for_batch(\n        batch_id=1,\n        strategy=\"balanced\",\n        limit=2\n    )\n    \n    assert len(result) == 2\n    \n    # Calculate expected balanced scores\n    # ISBN001: 40 * 0.6 + 20 * 0.4 = 24 + 8 = 32\n    # ISBN002: 20 * 0.6 + 60 * 0.4 = 12 + 24 = 36\n    \n    # ISBN002 should be first (higher balanced score)\n    assert result[0].isbn_or_asin == \"ISBN002\"\n    assert result[1].isbn_or_asin == \"ISBN001\"\n\n# ============================================================================\n# PATCH 4 TESTS: IntegrityError handling\n# ============================================================================\n\n@pytest.mark.asyncio\nasync def test_patch4_duplicate_isbn_in_batch_error(analysis_repo, sample_batch, db_session):\n    \"\"\"Test DuplicateIsbnInBatchError on duplicate ISBN in same batch\"\"\"\n    \n    # Create first analysis\n    analysis1 = await analysis_repo.create_analysis(\n        batch_id=1,\n        isbn_or_asin=\"ISBN001\",\n        roi_percent=Decimal(\"25.5\")\n    )\n    db_session.commit()\n    \n    assert analysis1.isbn_or_asin == \"ISBN001\"\n    \n    # Try to create duplicate in same batch\n    with pytest.raises(DuplicateIsbnInBatchError) as exc_info:\n        await analysis_repo.create_analysis(\n            batch_id=1,\n            isbn_or_asin=\"ISBN001\",  # Same ISBN, same batch\n            roi_percent=Decimal(\"35.2\")\n        )\n    \n    assert \"ISBN001\" in str(exc_info.value)\n    assert \"batch 1\" in str(exc_info.value)\n\n@pytest.mark.asyncio\nasync def test_patch4_same_isbn_different_batch_allowed(analysis_repo, db_session):\n    \"\"\"Test same ISBN allowed in different batches\"\"\"\n    \n    # Create two batches\n    batch1 = Batch(id=1, name=\"Batch 1\")\n    batch2 = Batch(id=2, name=\"Batch 2\")\n    db_session.add(batch1)\n    db_session.add(batch2)\n    db_session.commit()\n    \n    # Create same ISBN in different batches - should work\n    analysis1 = await analysis_repo.create_analysis(\n        batch_id=1,\n        isbn_or_asin=\"ISBN001\",\n        roi_percent=Decimal(\"25.5\")\n    )\n    \n    analysis2 = await analysis_repo.create_analysis(\n        batch_id=2,\n        isbn_or_asin=\"ISBN001\",  # Same ISBN, different batch\n        roi_percent=Decimal(\"35.2\")\n    )\n    \n    db_session.commit()\n    \n    assert analysis1.isbn_or_asin == analysis2.isbn_or_asin\n    assert analysis1.batch_id != analysis2.batch_id\n\n@pytest.mark.asyncio\nasync def test_patch4_isbn_normalization_in_create(analysis_repo, sample_batch, db_session):\n    \"\"\"Test ISBN normalization in create_analysis\"\"\"\n    \n    # Create analysis with lowercase/spaces\n    analysis = await analysis_repo.create_analysis(\n        batch_id=1,\n        isbn_or_asin=\" isbn001 \",  # Lowercase with spaces\n        roi_percent=Decimal(\"25.5\")\n    )\n    db_session.commit()\n    \n    assert analysis.isbn_or_asin == \"ISBN001\"  # Should be normalized\n\n# ============================================================================\n# INTEGRATION TESTS: All patches working together\n# ============================================================================\n\n@pytest.mark.asyncio\nasync def test_all_patches_integration(analysis_repo, sample_batch, db_session):\n    \"\"\"Test all patches working together\"\"\"\n    \n    # Create diverse test data\n    analyses_data = [\n        {\"isbn\": \"ISBN001\", \"roi\": Decimal(\"40.0\"), \"velocity\": Decimal(\"30.0\"), \"profit\": Decimal(\"15.50\")},\n        {\"isbn\": \"ISBN002\", \"roi\": Decimal(\"25.0\"), \"velocity\": Decimal(\"70.0\"), \"profit\": Decimal(\"12.25\")},\n        {\"isbn\": \"ISBN003\", \"roi\": Decimal(\"60.0\"), \"velocity\": Decimal(\"20.0\"), \"profit\": Decimal(\"18.75\")},\n        {\"isbn\": \"ISBN004\", \"roi\": Decimal(\"15.0\"), \"velocity\": Decimal(\"40.0\"), \"profit\": Decimal(\"8.30\")}\n    ]\n    \n    for data in analyses_data:\n        analysis = await analysis_repo.create_analysis(\n            batch_id=1,\n            isbn_or_asin=data[\"isbn\"],\n            roi_percent=data[\"roi\"],\n            velocity_score=data[\"velocity\"],\n            profit=data[\"profit\"]\n        )\n    db_session.commit()\n    \n    # ✅ PATCH 1: Test isbn_list filtering + other filters\n    roi_filter = FilterCriteria(field=\"roi_percent\", condition=FilterCondition.GTE, value=Decimal(\"30\"))\n    \n    result = await analysis_repo.list_filtered(\n        batch_id=1,\n        isbn_list=[\"ISBN001\", \"ISBN002\", \"ISBN003\"],  # PATCH 1\n        filters=[roi_filter],\n        sort_by=\"velocity_score\",  # PATCH 2 validation\n        sort_desc=True\n    )\n    \n    assert result.total == 2  # ISBN001 and ISBN003 have ROI >= 30\n    assert result.items[0].velocity_score >= result.items[1].velocity_score  # Sorted desc\n    \n    # ✅ PATCH 3: Test balanced strategy with Decimal precision\n    top_balanced = await analysis_repo.top_n_for_batch(\n        batch_id=1,\n        strategy=\"balanced\",\n        limit=3\n    )\n    \n    assert len(top_balanced) == 3\n    # Verify balanced scoring works correctly\n    \n    # ✅ PATCH 4: Test duplicate detection still works\n    with pytest.raises(DuplicateIsbnInBatchError):\n        await analysis_repo.create_analysis(\n            batch_id=1,\n            isbn_or_asin=\"ISBN001\"  # Duplicate\n        )\n\nif __name__ == \"__main__\":\n    # Run tests\n    pytest.main([__file__, \"-v\"])\n"